name: Pipeline CI/CD - Homologação
run-name: Pipeline CI executado por ${{ github.actor }} (#${{ github.run_number }})

on:
  workflow_dispatch:
    inputs:
      version-override:
        description: 'Sobrescrever versão do package.json (opcional, ex: 1.0.0)'
        required: false
        type: string
      create-tag:
        description: 'Criar tag Git com a versão?'
        required: false
        type: boolean
        default: false
      bump-type:
        description: 'Tipo de incremento de versão (se não informar version-override)'
        required: false
        type: choice
        options:
          - none
          - patch
          - minor
          - major
        default: none

permissions:
  contents: write
  security-events: write

jobs:
  ambiente-para-homologacao:
    name: Verificação dos Ambientes
    strategy:
      matrix:
        versao: [20, 22]
        plataforma: ["ubuntu"]
    runs-on: ${{ matrix.plataforma }}-latest
    
    steps:
      - name: Instalação do Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.versao }}
      
      - name: Exibição da versão e da plataforma
        run: |
          node --version
          echo ${{ runner.os }}

  build:
    name: Build
    needs: [ambiente-para-homologacao]
    runs-on: ubuntu-latest
    environment: homologacao
    outputs:
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
      
      - name: Ativar pnpm
        run: corepack enable
      
      - name: Cache de dependências
        uses: actions/cache@v4
        with:
          path: |
            ./api/node_modules
            ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-
      
      - name: Limpar instalação anterior
        working-directory: ./api
        run: |
          rm -rf node_modules .turbo dist
      
      - name: Instalar dependências
        working-directory: ./api
        run: pnpm install --frozen-lockfile
      
      - name: Determinar versão
        id: version
        working-directory: ./api
        run: |
          bump_version() {
            local version=$1
            local bump_type=$2
            
            IFS='.' read -ra VERSION_PARTS <<< "$version"
            MAJOR="${VERSION_PARTS[0]}"
            MINOR="${VERSION_PARTS[1]}"
            PATCH="${VERSION_PARTS[2]}"
            
            case $bump_type in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac
            
            echo "$MAJOR.$MINOR.$PATCH"
          }
          
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          echo "Versão do package.json: $PACKAGE_VERSION"
          
          if [ -n "${{ inputs.version-override }}" ]; then
            VERSION="${{ inputs.version-override }}"
            echo "Usando versão manual: $VERSION"
          elif [ "${{ inputs.bump-type }}" != "none" ]; then
            VERSION=$(bump_version "$PACKAGE_VERSION" "${{ inputs.bump-type }}")
            echo "Versão incrementada (${{ inputs.bump-type }}): $VERSION"
          else
            VERSION="$PACKAGE_VERSION"
            echo "Usando versão do package.json: $VERSION"
          fi
          
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Versão inválida: $VERSION"
            echo "Formato esperado: X.Y.Z (ex: 1.0.0, 2.3.4)"
            exit 1
          fi
          
          echo "Versão final: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
      
      - name: Atualizar package.json
        if: ${{ inputs.version-override != '' || inputs.bump-type != 'none' }}
        working-directory: ./api
        run: |
          echo "Atualizando package.json para versão ${{ steps.version.outputs.version }}"
          npm version ${{ steps.version.outputs.version }} --no-git-tag-version --allow-same-version
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add package.json
          git commit -m "chore: bump version to ${{ steps.version.outputs.version }} [skip ci]" || echo "Nenhuma alteração"
      
      - name: Gerar Prisma Client
        working-directory: ./api
        env:
          DATABASE_URL: postgresql://teste:senha_teste@localhost:5433/helpme_database_teste?schema=public
        run: pnpm run generate
      
      - name: Verificar TypeScript
        continue-on-error: true
        working-directory: ./api
        run: |
          echo "Verificando versão do TypeScript:"
          pnpm tsc --version
          echo "Executando type check:"
          pnpm tsc --noEmit --pretty
      
      - name: Build do projeto
        working-directory: ./api
        run: pnpm build
      
      - name: Verificar build gerado
        working-directory: ./api
        run: |
          echo "Conteúdo do diretório dist:"
          ls -lah dist/
          test -f dist/server.js && echo "[SUCESSO] server.js encontrado" || (echo "[ERROR] server.js NÃO encontrado" && exit 1)
      
      - name: Upload do build
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            ./api/dist
            ./api/node_modules
          retention-days: 1

  testes-unitarios:
    name: Testes Unitários
    needs: [build]
    runs-on: ubuntu-latest
    environment: homologacao
    
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
      
      - name: Ativar pnpm
        run: corepack enable
      
      - name: Cache de dependências
        uses: actions/cache@v4
        with:
          path: |
            ./api/node_modules
            ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-
      
      - name: Instalar dependências
        working-directory: ./api
        run: pnpm install --frozen-lockfile
      
      - name: Gerar Prisma Client
        working-directory: ./api
        env:
          DATABASE_URL: postgresql://teste:senha_teste@localhost:5433/helpme_database_teste?schema=public
        run: pnpm run generate
      
      - name: Executar testes unitários
        working-directory: ./api
        run: pnpm run test:unit
      
      - name: Upload de coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-unit
          path: ./api/coverage/
          retention-days: 7
        continue-on-error: true

  testes-e2e:
    name: Testes End-to-End
    needs: [testes-unitarios]
    runs-on: ubuntu-latest
    environment: homologacao
    
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
      
      - name: Ativar pnpm
        run: corepack enable
      
      - name: Cache de dependências
        uses: actions/cache@v4
        with:
          path: |
            ./api/node_modules
            ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-
      
      - name: Instalar dependências
        working-directory: ./api
        run: pnpm install --frozen-lockfile
      
      - name: Gerar Prisma Client
        working-directory: ./api
        env:
          DATABASE_URL: postgresql://teste:senha_teste@localhost:5433/helpme_database_teste?schema=public
        run: pnpm run generate
      
      - name: Limpeza NUCLEAR de ambiente
        run: |
          echo "=== LIMPEZA NUCLEAR DO AMBIENTE ==="
          
          # 1. PARAR TODOS OS CONTAINERS (sem exceção)
          echo "Parando TODOS os containers Docker..."
          if [ "$(docker ps -q | wc -l)" -gt 0 ]; then
            docker ps -q | xargs -r docker stop -t 2 2>/dev/null || true
            echo "  Containers parados"
          else
            echo "  Nenhum container em execução"
          fi
          
          # 2. REMOVER TODOS OS CONTAINERS (sem exceção)
          echo ""
          echo "Removendo TODOS os containers Docker..."
          if [ "$(docker ps -aq | wc -l)" -gt 0 ]; then
            TOTAL=$(docker ps -aq | wc -l)
            echo "  Encontrados $TOTAL containers para remover"
            docker ps -aq | xargs -r docker rm -f 2>/dev/null || true
            echo "  Containers removidos"
          else
            echo "  Nenhum container para remover"
          fi
          
          # 3. REMOVER TODAS AS REDES customizadas
          echo ""
          echo "Removendo TODAS as redes Docker customizadas..."
          CUSTOM_NETWORKS=$(docker network ls --filter type=custom -q 2>/dev/null | wc -l)
          if [ "$CUSTOM_NETWORKS" -gt 0 ]; then
            docker network ls --filter type=custom -q | xargs -r docker network rm 2>/dev/null || true
            echo "  Redes removidas"
          else
            echo "  Nenhuma rede customizada"
          fi
          
          # 4. REMOVER TODOS OS VOLUMES
          echo ""
          echo "Removendo TODOS os volumes Docker..."
          if [ "$(docker volume ls -q | wc -l)" -gt 0 ]; then
            TOTAL=$(docker volume ls -q | wc -l)
            echo "  Encontrados $TOTAL volumes para remover"
            docker volume ls -q | xargs -r docker volume rm -f 2>/dev/null || true
            echo "  Volumes removidos"
          else
            echo "  Nenhum volume para remover"
          fi
          
          # 5. Parar Docker daemon
          echo ""
          echo "Parando Docker daemon..."
          sudo systemctl stop docker.socket docker.service || true
          sleep 3
          
          # 6. Matar TODOS os processos relacionados
          echo ""
          echo "Eliminando processos Docker e serviços..."
          sudo pkill -9 dockerd || true
          sudo pkill -9 containerd || true
          sudo pkill -9 docker-proxy || true
          sudo pkill -9 postgres || true
          sudo pkill -9 mongod || true
          sudo pkill -9 redis-server || true
          sudo pkill -9 java || true
          sleep 3
          
          # 7. Liberar portas específicas de forma agressiva
          echo ""
          echo "Liberando portas críticas..."
          PORTAS=(5432 5433 27017 27018 6379 2181 9092 9093 8086)
          for porta in "${PORTAS[@]}"; do
            sudo fuser -k ${porta}/tcp 2>/dev/null || true
            sudo lsof -ti:${porta} | xargs -r sudo kill -9 2>/dev/null || true
            sudo netstat -tlnp 2>/dev/null | grep ":${porta} " | awk '{print $7}' | cut -d'/' -f1 | xargs -r sudo kill -9 2>/dev/null || true
          done
          sleep 5
          
          # 8. Limpar estado do Docker
          echo ""
          echo "Limpando estado do Docker..."
          sudo rm -rf /var/lib/docker/containers/* || true
          sudo rm -rf /var/lib/docker/network/files/* || true
          sudo rm -rf /var/run/docker/netns/* || true
          sudo rm -rf /var/lib/docker/overlay2/* || true
          
          # 9. Configurar Docker daemon
          echo ""
          echo "Configurando Docker daemon..."
          sudo mkdir -p /etc/docker
          cat <<EOF | sudo tee /etc/docker/daemon.json
          {
            "max-concurrent-downloads": 3,
            "max-download-attempts": 5,
            "live-restore": false,
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "10m",
              "max-file": "3"
            }
          }
          EOF
          
          # 10. Reiniciar Docker limpo
          echo ""
          echo "Reiniciando Docker daemon..."
          sudo systemctl start docker.service
          sleep 8
          
          # 11. Verificar Docker está funcionando
          if ! docker info >/dev/null 2>&1; then
            echo "[ERROR] Docker falhou ao iniciar!"
            sudo systemctl status docker.service
            sudo journalctl -xeu docker.service --no-pager | tail -50
            exit 1
          fi
          
          # 12. Limpeza total do Docker (system prune)
          echo ""
          echo "Executando limpeza do sistema Docker..."
          docker system prune -af --volumes 2>/dev/null || true
          docker network prune -f 2>/dev/null || true
          docker volume prune -f 2>/dev/null || true
          
          # 13. VERIFICAÇÃO FINAL COMPLETA
          echo ""
          echo "=== VERIFICAÇÃO FINAL ==="
          
          # Verificar containers
          CONTAINERS_COUNT=$(docker ps -aq | wc -l)
          if [ "$CONTAINERS_COUNT" -gt 0 ]; then
            echo "[ERROR] Ainda existem $CONTAINERS_COUNT containers!"
            docker ps -a
            exit 1
          else
            echo "[SUCESSO] Nenhum container no sistema"
          fi
          
          # Verificar redes customizadas
          NETWORKS_COUNT=$(docker network ls --filter type=custom -q | wc -l)
          if [ "$NETWORKS_COUNT" -gt 0 ]; then
            echo "[WARN] Existem $NETWORKS_COUNT redes customizadas"
            docker network ls
          else
            echo "[SUCESSO] Nenhuma rede customizada"
          fi
          
          # Verificar volumes
          VOLUMES_COUNT=$(docker volume ls -q | wc -l)
          if [ "$VOLUMES_COUNT" -gt 0 ]; then
            echo "[WARN] Existem $VOLUMES_COUNT volumes"
            docker volume ls
          else
            echo "[SUCESSO] Nenhum volume"
          fi
          
          # Verificar portas
          PORTS_OK=true
          for porta in "${PORTAS[@]}"; do
            if sudo lsof -i :${porta} >/dev/null 2>&1; then
              echo "[WARN] PORTA ${porta} AINDA OCUPADA!"
              sudo lsof -i :${porta}
              PORTS_OK=false
            else
              echo "[SUCESSO] Porta ${porta} livre"
            fi
          done
          
          if [ "$PORTS_OK" = false ]; then
            echo ""
            echo "[ERROR] Algumas portas ainda estão ocupadas!"
            exit 1
          fi
          
          echo ""
          echo "=== AMBIENTE 100% LIMPO E PRONTO ==="

      - name: Aguardar estabilização completa do ambiente
        run: |
          echo "=== AGUARDANDO ESTABILIZAÇÃO DO AMBIENTE ==="
          
          # Aguardar 10 segundos para sistema operacional liberar recursos
          echo "Aguardando sistema operacional liberar recursos..."
          sleep 10
          
          # Verificar múltiplas vezes se portas estão realmente livres
          echo ""
          echo "Verificando liberação de portas (3 verificações)..."
          PORTAS=(5432 5433 27017 27018 6379 2181 9092 9093 8086)
          
          for tentativa in {1..3}; do
            echo ""
            echo "Verificação #$tentativa:"
            PORTAS_OCUPADAS=false
            
            for porta in "${PORTAS[@]}"; do
              if sudo lsof -i :${porta} >/dev/null 2>&1; then
                echo "  [WARN] Porta ${porta} ainda ocupada na tentativa ${tentativa}"
                PORTAS_OCUPADAS=true
                
                # Tentar liberar novamente
                sudo fuser -k ${porta}/tcp 2>/dev/null || true
                sudo lsof -ti:${porta} | xargs -r sudo kill -9 2>/dev/null || true
              else
                echo "  [OK] Porta ${porta} livre"
              fi
            done
            
            if [ "$PORTAS_OCUPADAS" = false ]; then
              echo ""
              echo "[SUCESSO] Todas as portas livres na verificação #${tentativa}"
              break
            fi
            
            if [ $tentativa -lt 3 ]; then
              echo ""
              echo "Aguardando 5 segundos antes da próxima verificação..."
              sleep 5
            fi
          done
          
          # Verificação final RIGOROSA
          echo ""
          echo "=== VERIFICAÇÃO FINAL RIGOROSA ==="
          FINAL_CHECK_FAILED=false
          
          for porta in "${PORTAS[@]}"; do
            if sudo lsof -i :${porta} >/dev/null 2>&1; then
              echo "[ERROR] Porta ${porta} AINDA OCUPADA após 3 tentativas!"
              sudo lsof -i :${porta}
              FINAL_CHECK_FAILED=true
            fi
          done
          
          if [ "$FINAL_CHECK_FAILED" = true ]; then
            echo ""
            echo "[ERROR] Falha na liberação de portas! Abortando..."
            exit 1
          fi
          
          # Verificar que não existem containers
          CONTAINERS=$(docker ps -aq | wc -l)
          if [ "$CONTAINERS" -gt 0 ]; then
            echo "[ERROR] Ainda existem $CONTAINERS containers!"
            docker ps -a
            exit 1
          fi
          
          echo ""
          echo "=== AMBIENTE COMPLETAMENTE ESTABILIZADO ==="

      - name: Diagnóstico de ambiente
        run: |
          echo "=== DIAGNÓSTICO DO AMBIENTE ==="
          
          echo "Docker Info:"
          docker info | grep -E 'Server Version|Storage Driver|Logging Driver'
          
          echo ""
          echo "Containers Docker:"
          CONTAINERS_COUNT=$(docker ps -aq | wc -l)
          echo "  Total: $CONTAINERS_COUNT containers"
          if [ "$CONTAINERS_COUNT" -gt 0 ]; then
            docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          fi
          
          echo ""
          echo "Redes Docker:"
          docker network ls
          
          echo ""
          echo "Volumes Docker:"
          VOLUMES_COUNT=$(docker volume ls -q | wc -l)
          echo "  Total: $VOLUMES_COUNT volumes"
          if [ "$VOLUMES_COUNT" -gt 0 ]; then
            docker volume ls
          fi
          
          echo ""
          echo "Processos escutando em portas críticas:"
          sudo netstat -tlnp 2>/dev/null | grep -E ':(5432|5433|27017|27018|6379|9092|9093|2181|8086)' || echo "  Nenhum processo [SUCESSO]"
          
          echo ""
          echo "Espaço em disco:"
          df -h /var/lib/docker
          
          echo ""
          echo "=== DIAGNÓSTICO CONCLUÍDO ==="
      
      - name: Subir infraestrutura com Docker Compose
        working-directory: ./api
        run: |
          echo "=== SUBINDO INFRAESTRUTURA DE TESTES ==="
          
          # Verificação de segurança final
          EXISTING=$(docker ps -aq | wc -l)
          if [ "$EXISTING" -gt 0 ]; then
            echo "[ERROR] CRÍTICO: Ainda existem $EXISTING containers após limpeza nuclear!"
            docker ps -a
            exit 1
          fi
          
          echo "[SUCESSO] Ambiente 100% limpo confirmado"
          
          # Pull de imagens com retry
          echo ""
          echo "Baixando imagens Docker..."
          for i in {1..3}; do
            if docker compose -f docker-compose.test.yml pull --quiet; then
              echo "[SUCESSO] Imagens baixadas com sucesso"
              break
            fi
            echo "[WARN] Tentativa $i/3 de pull falhou, tentando novamente..."
            sleep 5
          done
          
          # Subir containers
          echo ""
          echo "Iniciando containers..."
          docker compose -f docker-compose.test.yml up -d \
            --force-recreate \
            --remove-orphans \
            --renew-anon-volumes \
            --timeout 60
          
          # Aguardar inicialização
          echo ""
          echo "Aguardando serviços iniciarem (20s)..."
          sleep 20
          
          # Verificar status
          echo ""
          echo "Status dos containers:"
          docker compose -f docker-compose.test.yml ps -a
          
          # Verificar se todos os containers estão running
          echo ""
          echo "Verificando saúde dos containers..."
          FAILED_CONTAINERS=$(docker compose -f docker-compose.test.yml ps --format json 2>/dev/null | jq -r 'select(.State != "running") | .Name' || echo "")
          
          if [ -n "$FAILED_CONTAINERS" ]; then
            echo "[WARN] Containers com problema:"
            echo "$FAILED_CONTAINERS"
            echo ""
            echo "Logs dos containers com falha:"
            docker compose -f docker-compose.test.yml logs --tail=50
            exit 1
          fi
          
          echo "[SUCESSO] Todos os containers estão rodando"
          echo ""
          echo "=== INFRAESTRUTURA PRONTA ==="

      - name: Verificar saúde dos serviços
        working-directory: ./api
        run: |
          echo "=== VERIFICANDO SAÚDE DOS SERVIÇOS ==="
          
          echo "1. Testando PostgreSQL..."
          if docker compose -f docker-compose.test.yml exec -T postgres \
             psql -U teste -d helpme_database_teste -c "SELECT version();" >/dev/null 2>&1; then
            VERSION=$(docker compose -f docker-compose.test.yml exec -T postgres \
                      psql -U teste -d helpme_database_teste -tc "SELECT version();" | xargs)
            echo "[SUCESSO] PostgreSQL operacional: ${VERSION:0:50}..."
          else
            echo "[ERROR] PostgreSQL falhou no teste"
            exit 1
          fi
          
          echo ""
          echo "2. Testando MongoDB..."
          if MONGO_VERSION=$(docker compose -f docker-compose.test.yml exec -T mongodb \
             mongosh --quiet --eval "db.version()" 2>/dev/null); then
            echo "[SUCESSO] MongoDB operacional: v$MONGO_VERSION"
          else
            echo "[ERROR] MongoDB falhou no teste"
            exit 1
          fi
          
          echo ""
          echo "3. Testando Redis..."
          docker compose -f docker-compose.test.yml exec -T redis redis-cli set healthcheck "ok" >/dev/null
          REDIS_VALUE=$(docker compose -f docker-compose.test.yml exec -T redis redis-cli get healthcheck 2>/dev/null | tr -d '\r')
          docker compose -f docker-compose.test.yml exec -T redis redis-cli del healthcheck >/dev/null
          
          if [ "$REDIS_VALUE" = "ok" ]; then
            REDIS_VERSION=$(docker compose -f docker-compose.test.yml exec -T redis redis-cli --version | awk '{print $2}')
            echo "[SUCESSO] Redis operacional: $REDIS_VERSION"
          else
            echo "[ERROR] Redis falhou no teste (retornou: '$REDIS_VALUE')"
            exit 1
          fi
          
          echo ""
          echo "4. Testando Zookeeper..."
          if docker compose -f docker-compose.test.yml exec -T zookeeper \
             bash -c "timeout 3 bash -c '</dev/tcp/localhost/2181' 2>/dev/null"; then
            echo "[SUCESSO] Zookeeper operacional (porta 2181 respondendo)"
          else
            echo "[ERROR] Zookeeper não está respondendo na porta 2181"
            docker compose -f docker-compose.test.yml logs zookeeper --tail=30
            exit 1
          fi
          
          echo ""
          echo "5. Testando Kafka..."
          
          if docker compose -f docker-compose.test.yml exec -T kafka \
             bash -c "timeout 3 bash -c '</dev/tcp/localhost/9092' 2>/dev/null"; then
            echo "[SUCESSO] Kafka porta 9092 respondendo"
          else
            echo "[ERROR] Kafka porta 9092 não responde"
            exit 1
          fi
          
          if docker compose -f docker-compose.test.yml exec -T kafka \
             kafka-broker-api-versions --bootstrap-server localhost:9092 2>&1 | grep -q "ApiVersion"; then
            echo "[SUCESSO] Kafka API respondendo"
          else
            echo "[ERROR] Kafka API não responde"
            docker compose -f docker-compose.test.yml logs kafka --tail=50
            exit 1
          fi
          
          echo "  Criando tópico de teste..."
          if docker compose -f docker-compose.test.yml exec -T kafka \
             kafka-topics --bootstrap-server localhost:9092 \
             --create --topic healthcheck-test \
             --partitions 1 --replication-factor 1 \
             --if-not-exists >/dev/null 2>&1; then
            
            if docker compose -f docker-compose.test.yml exec -T kafka \
               kafka-topics --bootstrap-server localhost:9092 --list 2>/dev/null | grep -q "healthcheck-test"; then
              echo "[SUCESSO] Kafka operacional (tópico criado com sucesso)"
              
              docker compose -f docker-compose.test.yml exec -T kafka \
                kafka-topics --bootstrap-server localhost:9092 \
                --delete --topic healthcheck-test >/dev/null 2>&1 || true
            else
              echo "[ERROR] Kafka não conseguiu listar tópicos"
              exit 1
            fi
          else
            echo "[ERROR] Kafka não conseguiu criar tópico"
            exit 1
          fi
          
          echo ""
          echo "6. Testando InfluxDB..."
          if docker compose -f docker-compose.test.yml exec -T influxdb influx ping >/dev/null 2>&1; then
            echo "[SUCESSO] InfluxDB operacional"
          else
            echo "[ERROR] InfluxDB falhou no teste"
            exit 1
          fi
          
          echo ""
          echo "=== VERIFICAÇÃO CONCLUÍDA COM SUCESSO ==="
          
          echo ""
          echo "[INFO] Resumo dos serviços:"
          docker compose -f docker-compose.test.yml ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"

      - name: Executar migrations
        working-directory: ./api
        env:
          DATABASE_URL: postgresql://teste:senha_teste@localhost:5433/helpme_database_teste?schema=public
        run: |
          echo "=== EXECUTANDO MIGRATIONS ==="
          pnpm run migrate
          echo "[SUCESSO] Migrations executadas"
      
      - name: Popular banco de dados (seed)
        working-directory: ./api
        run: |
          echo "=== POPULANDO BANCO DE DADOS ==="
          pnpm run seed-big-ci
          echo "[SUCESSO] Seed executado"

      - name: Executar testes E2E
        working-directory: ./api
        run: |
          echo "=== EXECUTANDO TESTES E2E ==="
          pnpm run test:e2e
          echo "[SUCESSO] Testes E2E concluídos"

      - name: Upload de coverage E2E
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-e2e
          path: ./api/coverage/
          retention-days: 7
        continue-on-error: true
      
      - name: Logs dos serviços (em caso de falha)
        working-directory: ./api
        if: failure()
        run: |
          echo "=== LOGS DOS SERVIÇOS ==="
          
          echo "PostgreSQL Logs:"
          docker compose -f docker-compose.test.yml logs --tail=100 postgres
          
          echo ""
          echo "MongoDB Logs:"
          docker compose -f docker-compose.test.yml logs --tail=100 mongodb
          
          echo ""
          echo "Redis Logs:"
          docker compose -f docker-compose.test.yml logs --tail=100 redis
          
          echo ""
          echo "Zookeeper Logs:"
          docker compose -f docker-compose.test.yml logs --tail=100 zookeeper
          
          echo ""
          echo "Kafka Logs:"
          docker compose -f docker-compose.test.yml logs --tail=100 kafka
          
          echo ""
          echo "InfluxDB Logs:"
          docker compose -f docker-compose.test.yml logs --tail=100 influxdb

      - name: Derrubar infraestrutura
        working-directory: ./api 
        if: always()
        run: |
          echo "=== DERRUBANDO INFRAESTRUTURA ==="
          docker compose -f docker-compose.test.yml down -v --timeout 30
          echo "[SUCESSO] Infraestrutura derrubada"

  release:
    name: Build e Push Docker Image
    runs-on: ubuntu-latest
    needs: [build, testes-unitarios, testes-e2e]
    environment: homologacao
    outputs:
      version: ${{ needs.build.outputs.version }}
      tags: ${{ steps.meta.outputs.tags }}
    
    steps:
      - name: Checkout do código
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Extrair metadados Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKERHUB_USERNAME }}/helpme-api
          tags: |
            type=raw,value=${{ needs.build.outputs.version }}
            type=raw,value=latest
            type=raw,value=homolog
            type=sha,prefix=sha-
            type=raw,value=build-${{ github.run_number }}
          flavor: |
            latest=auto
      
      - name: Análise do Dockerfile com Hadolint
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: ./api/Dockerfile
        continue-on-error: true
      
      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build e Push da imagem
        uses: docker/build-push-action@v6
        with:
          push: true
          context: ./api
          file: ./api/Dockerfile
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/helpme-api:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/helpme-api:buildcache,mode=max
          build-args: |
            VERSION=${{ needs.build.outputs.version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            GIT_COMMIT=${{ github.sha }}
      
      - name: Scan de vulnerabilidades com Trivy
        uses: aquasecurity/trivy-action@0.32.0
        with:
          scan-type: 'image'
          image-ref: ${{ secrets.DOCKERHUB_USERNAME }}/helpme-api:${{ needs.build.outputs.version }}
          format: sarif
          output: trivy-results.sarif
          severity: "UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL"
        continue-on-error: true
      
      - name: Upload resultados do Trivy
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          category: trivy-docker-scan
          sarif_file: trivy-results.sarif
        continue-on-error: true
      
      - name: Criar tag Git
        if: ${{ inputs.create-tag }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git tag -a "v${{ needs.build.outputs.version }}" -m "Release v${{ needs.build.outputs.version }}"
          git push origin "v${{ needs.build.outputs.version }}"
          echo "[SUCESSO] Tag v${{ needs.build.outputs.version }} criada e enviada"
      
      - name: Resumo da release
        run: |
          echo "## Release v${{ needs.build.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Versão" >> $GITHUB_STEP_SUMMARY
          echo "- **Versão**: \`${{ needs.build.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ inputs.version-override }}" ]; then
            echo "- **Origem**: Manual override" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ inputs.bump-type }}" != "none" ]; then
            echo "- **Origem**: Auto-incremento (${{ inputs.bump-type }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Origem**: package.json" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Imagens Docker Publicadas" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Informações da Build" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Build**: #${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Executor**: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Data**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Como usar:" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Versão específica" >> $GITHUB_STEP_SUMMARY
          echo "docker pull ${{ secrets.DOCKERHUB_USERNAME }}/helpme-api:${{ needs.build.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Última versão" >> $GITHUB_STEP_SUMMARY
          echo "docker pull ${{ secrets.DOCKERHUB_USERNAME }}/helpme-api:latest" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ inputs.create-tag }}" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Tag Git criada" >> $GITHUB_STEP_SUMMARY
            echo "Tag **v${{ needs.build.outputs.version }}** foi criada no repositório" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "Pipeline executada com sucesso!" >> $GITHUB_STEP_SUMMARY